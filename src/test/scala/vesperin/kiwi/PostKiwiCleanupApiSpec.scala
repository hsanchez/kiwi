package vesperin.kiwi

import vesperin.kiwi.domain._
import org.specs2.mutable.Specification
import spray.http.{HttpEntity, MediaTypes}
import spray.testkit.Specs2RouteTest
import vesperin.kiwi.routes.Kiwi

import scala.concurrent.duration._

/**
 * @author hsanchez@cs.ucsc.edu (Huascar A. Sanchez)
 */
class PostKiwiCleanupApiSpec extends Specification with Specs2RouteTest with Kiwi {
  def actorRefFactory = system

  // reason of this addition? see https://groups.google.com/forum/#!msg/spray-user/o8DtI6VUMbA/n9tguTb_1noJ
  implicit val routeTestTimeout = RouteTestTimeout(FiniteDuration(5, SECONDS))

  "Kiwi" should {
    "Return a cleanup request for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", Command(cleanup = Some(Cleanup(Code(id = "new", name = "ToSort.java", description = "Name class", content = "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.*;\n\npublic class ToSort implements Comparable {\n\n    private Float val;\n    private String id;\n\n    public ToSort(Float val, String id) {\n      this.val = val;\n      this.id = id;\n    }\n\n    @Override\n    public int compareTo(Object o) {\n\n      ToSort f = (ToSort) o;\n\n      if (val.floatValue() > f.val.floatValue()) {\n        return 1;\n      } else if (val.floatValue() < f.val.floatValue()) {\n        return -1;\n      } else {\n        return 0;\n      }\n\n    }\n\n    @Override\n    public String toString() {\n      return this.id;\n    }\n  }"))))) ~>
        sealRoute(routes) ~> check {

        responseAs[Result].draft.get.before === Code(id = "new", name = "ToSort.java", description = "Name class", content = "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.*;\n\npublic class ToSort implements Comparable {\n\n    private Float val;\n    private String id;\n\n    public ToSort(Float val, String id) {\n      this.val = val;\n      this.id = id;\n    }\n\n    @Override\n    public int compareTo(Object o) {\n\n      ToSort f = (ToSort) o;\n\n      if (val.floatValue() > f.val.floatValue()) {\n        return 1;\n      } else if (val.floatValue() < f.val.floatValue()) {\n        return -1;\n      } else {\n        return 0;\n      }\n\n    }\n\n    @Override\n    public String toString() {\n      return this.id;\n    }\n  }")
        responseAs[Result].draft.get.after  === Code(id = "new", name = "ToSort.java", description = "Name class", content = "import java.util.*;\n\npublic class ToSort implements Comparable {\n\n  private Float val;\n  private String id;\n\n  public ToSort(Float val, String id) {\n    this.val = val;\n    this.id = id;\n  }\n\n  @Override\n  public int compareTo(Object o) {\n\n    ToSort f = (ToSort) o;\n\n    if (val.floatValue() > f.val.floatValue()) {\n      return 1;\n    } else if (val.floatValue() < f.val.floatValue()) {\n      return -1;\n    } else {\n      return 0;\n    }\n\n  }\n\n  @Override\n  public String toString() {\n    return this.id;\n  }\n}")
      }
    }

    "Return a cleanup request for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", Command(cleanup = Some(Cleanup(Code(id = "new", name = "Name.java", description = "Name class", content = "class Name {\n\t/** {@link Name#boom(String)} **/\tvoid boom(){ System.out.println(1); }\n\tvoid baam(){ System.out.println(1); }\n\tvoid beem(){ System.out.println(1); }\n\tvoid buum(){ baam(); }\n}"))))) ~>
        sealRoute(routes) ~> check {
        responseAs[Result].draft.get.before === Code(id = "new", name = "Name.java", description = "Name class", content = "class Name {\n\t/** {@link Name#boom(String)} **/\tvoid boom(){ System.out.println(1); }\n\tvoid baam(){ System.out.println(1); }\n\tvoid beem(){ System.out.println(1); }\n\tvoid buum(){ baam(); }\n}")
        responseAs[Result].draft.get.after  === Code(id = "new", name = "Name.java", description = "Name class", content = "class Name {\n  /** {@link Name#boom(String)} **/\n  void boom() {\n    System.out.println(1);\n  }\n\n  void buum() {\n    boom();\n  }\n}")
      }
    }

    "Return a cleanup request in JSON form for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", HttpEntity(MediaTypes.`application/json`, """{"cleanup": { "source": {"id":"new", "name": "Name.java", "description":"Name class", "content":"class Name {\n\t/** {@link Name#boom(String)} **/\tvoid boom(){ System.out.println(1); }\n\tvoid baam(){ System.out.println(1); }\n\tvoid beem(){ System.out.println(1); }\n\tvoid buum(){ baam(); }\n}", "tags":[], "datastructures": [], "algorithms": [], "refactorings": [], "confidence": 2, "comments":[]}, "preprocess": false }}""" )) ~>
        sealRoute(routes) ~> check {
        responseAs[Result].draft.get.before === Code(id = "new", name = "Name.java", description = "Name class", content = "class Name {\n\t/** {@link Name#boom(String)} **/\tvoid boom(){ System.out.println(1); }\n\tvoid baam(){ System.out.println(1); }\n\tvoid beem(){ System.out.println(1); }\n\tvoid buum(){ baam(); }\n}")
        responseAs[Result].draft.get.after  === Code(id = "new", name = "Name.java", description = "Name class", content = "class Name {\n  /** {@link Name#boom(String)} **/\n  void boom() {\n    System.out.println(1);\n  }\n\n  void buum() {\n    boom();\n  }\n}")
      }
    }


    "Return a cleanup request (with preprocessing) in JSON form for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", HttpEntity(MediaTypes.`application/json`, """{"cleanup": { "source": {"id":"new", "name": "Scratched.java", "description":"Scratched class", "content":"/** {@link Name#boom(String)} **/\tvoid boom(){ System.out.println(1); }\n\tvoid baam(){ System.out.println(1); }\n\tvoid beem(){ System.out.println(1); }\n\tvoid buum(){ baam(); }", "tags":[], "datastructures": [], "algorithms": [], "refactorings": [], "confidence": 2, "comments":[]}, "preprocess":true }}""" )) ~>
        sealRoute(routes) ~> check {
        responseAs[Result].draft.get.before mustEqual Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "/** {@link Name#boom(String)} **/\tvoid boom(){ System.out.println(1); }\n\tvoid baam(){ System.out.println(1); }\n\tvoid beem(){ System.out.println(1); }\n\tvoid buum(){ baam(); }")
        responseAs[Result].draft.get.after  mustEqual Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "/** {@link Name#boom(String)} **/\tvoid boom(){ System.out.println(1); }\n\tvoid buum(){ boom(); }")
      }
    }

    "Return a cleanup request (with preprocessing 2) in JSON form for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", HttpEntity(MediaTypes.`application/json`, """{"cleanup": { "source": {"id":"new", "name": "Scratched.java", "description":"Scratched class", "content":"public static void quicksort(int[] a, int p, int r)\n    {\n        int q;\n        while (p < r)\n        {\n            q = partition(a, p, r);\n            quicksort(a, p, q - 1);\n            p = q + 1;\n        }\n    }\n\n    public static int partition(int[] a, int p, int r)\n    {\n        int j = p - 1;\n        int x = a[r];\n        for (int i = p; i < r; i++)\n        {\n            if (a[i] <= x)\n            {\n                j++;\n                swap(a, i, j);\n            }\n        }\n        j++;\n        swap(a, j, r);\n        return j;\n    }\n\n    private static void swap(int[] a, int i, int j)\n    {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }", "tags":[], "datastructures": [], "algorithms": [], "refactorings": [], "confidence": 2, "comments":[]}, "preprocess":true }}""" )) ~>
        sealRoute(routes) ~> check {
        responseAs[Result].draft.get.before mustEqual Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "public static void quicksort(int[] a, int p, int r)\n    {\n        int q;\n        while (p < r)\n        {\n            q = partition(a, p, r);\n            quicksort(a, p, q - 1);\n            p = q + 1;\n        }\n    }\n\n    public static int partition(int[] a, int p, int r)\n    {\n        int j = p - 1;\n        int x = a[r];\n        for (int i = p; i < r; i++)\n        {\n            if (a[i] <= x)\n            {\n                j++;\n                swap(a, i, j);\n            }\n        }\n        j++;\n        swap(a, j, r);\n        return j;\n    }\n\n    private static void swap(int[] a, int i, int j)\n    {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }")
        responseAs[Result].draft.get.after  mustEqual Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "public static void quicksort(int[] a, int p, int r)\n    {\n        int q;\n        while (p < r)\n        {\n            q = partition(a, p, r);\n            quicksort(a, p, q - 1);\n            p = q + 1;\n        }\n    }\n\n    public static int partition(int[] a, int p, int r)\n    {\n        int j = p - 1;\n        int x = a[r];\n        for (int i = p; i < r; i++)\n        {\n            if (a[i] <= x)\n            {\n                j++;\n                swap(a, i, j);\n            }\n        }\n        j++;\n        swap(a, j, r);\n        return j;\n    }\n\n    private static void swap(int[] a, int i, int j)\n    {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }")
      }
    }

    "Return a cleanup request (optimize) in JSON form for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", HttpEntity(MediaTypes.`application/json`, """{"cleanup": { "source": {"id":"new", "name": "Quicksort.java", "description":"Quicksort algorithm", "content":"import java.util.Random;\n\npublic class Quicksort {\n  private static int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    int i = left - 1;\n    int j = right + 1;\n    while (true) {\n      do {\n        j--;\n      } while (arr[j] > pivot);\n\n      do {\n        i++;\n      } while (arr[i] < pivot);\n\n      if (i < j) {\n        swap(arr, i, j);\n      } else {\n        return j;\n      }\n    }\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n\n\n}", "tags":[], "datastructures": [], "algorithms": [], "refactorings": [], "confidence": 2, "comments":[]}, "preprocess": false }}""" )) ~>
        sealRoute(routes) ~> check {
        responseAs[Result].draft.get.before === Code(id = "new", name = "Quicksort.java", description = "Quicksort algorithm", content = "import java.util.Random;\n\npublic class Quicksort {\n  private static int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    int i = left - 1;\n    int j = right + 1;\n    while (true) {\n      do {\n        j--;\n      } while (arr[j] > pivot);\n\n      do {\n        i++;\n      } while (arr[i] < pivot);\n\n      if (i < j) {\n        swap(arr, i, j);\n      } else {\n        return j;\n      }\n    }\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n\n\n}")
        responseAs[Result].draft.get.after  === Code(id = "new", name = "Quicksort.java", description = "Quicksort algorithm", content = "public class Quicksort {\n  private static int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    int i = left - 1;\n    int j = right + 1;\n    while (true) {\n      do {\n        j--;\n      } while (arr[j] > pivot);\n\n      do {\n        i++;\n      } while (arr[i] < pivot);\n\n      if (i < j) {\n        swap(arr, i, j);\n      } else {\n        return j;\n      }\n    }\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n\n\n}")
      }
    }

    "Return a cleanup request (optimize of partial example) in JSON form for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", HttpEntity(MediaTypes.`application/json`, """{"cleanup": { "source": {"id":"new", "name": "Scratched.java", "description":"Scratched class", "content":"public static void main(String[] args) {\n        //insert random value in array\n        Scanner sc=new Scanner(System.in);\n        System.out.println(\"no of element\");\n        int noEle=sc.nextInt();\n        int[] eleArr=new int[noEle] ;//storing element in this array\n        for(int i=0;i<noEle;i++)\n        {\n            eleArr[i]=sc.nextInt();//enter element for storing \n        }\n        for(int i=0;i<eleArr.length;i++)\n        {\n            for(int j=0;j<eleArr.length-1;j++)\n        {\n            if(eleArr[j]>eleArr[j+1])\n            {//nothing but swaping logic without taking third variable\n                eleArr[j]=eleArr[j]+eleArr[j+1];\n                eleArr[j+1]=eleArr[j]-eleArr[j+1];\n                eleArr[j]=eleArr[j]-eleArr[j+1];\n            }\n        }\n        }\n        //getting sorted elemen as bubblesort\n        for(int i=0;i<noEle;i++)\n        {\n            System.out.print(eleArr[i]+\" \");  \n        }\n        System.out.println();\n    }", "tags":[], "datastructures": [], "algorithms": [], "refactorings": [], "confidence": 2, "comments":[]}, "preprocess": true }}""" )) ~>
        sealRoute(routes) ~> check {

        responseAs[Result].draft.get.before === Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "public static void main(String[] args) {\n        //insert random value in array\n        Scanner sc=new Scanner(System.in);\n        System.out.println(\"no of element\");\n        int noEle=sc.nextInt();\n        int[] eleArr=new int[noEle] ;//storing element in this array\n        for(int i=0;i<noEle;i++)\n        {\n            eleArr[i]=sc.nextInt();//enter element for storing \n        }\n        for(int i=0;i<eleArr.length;i++)\n        {\n            for(int j=0;j<eleArr.length-1;j++)\n        {\n            if(eleArr[j]>eleArr[j+1])\n            {//nothing but swaping logic without taking third variable\n                eleArr[j]=eleArr[j]+eleArr[j+1];\n                eleArr[j+1]=eleArr[j]-eleArr[j+1];\n                eleArr[j]=eleArr[j]-eleArr[j+1];\n            }\n        }\n        }\n        //getting sorted elemen as bubblesort\n        for(int i=0;i<noEle;i++)\n        {\n            System.out.print(eleArr[i]+\" \");  \n        }\n        System.out.println();\n    }")
        responseAs[Result].draft.get.after  === Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "public static void main(String[] args) {\n        //insert random value in array\n        Scanner sc=new Scanner(System.in);\n        System.out.println(\"no of element\");\n        int noEle=sc.nextInt();\n        int[] eleArr=new int[noEle] ;//storing element in this array\n        for(int i=0;i<noEle;i++)\n        {\n            eleArr[i]=sc.nextInt();//enter element for storing \n        }\n        for(int i=0;i<eleArr.length;i++)\n        {\n            for(int j=0;j<eleArr.length-1;j++)\n        {\n            if(eleArr[j]>eleArr[j+1])\n            {//nothing but swaping logic without taking third variable\n                eleArr[j]=eleArr[j]+eleArr[j+1];\n                eleArr[j+1]=eleArr[j]-eleArr[j+1];\n                eleArr[j]=eleArr[j]-eleArr[j+1];\n            }\n        }\n        }\n        //getting sorted elemen as bubblesort\n        for(int i=0;i<noEle;i++)\n        {\n            System.out.print(eleArr[i]+\" \");  \n        }\n        System.out.println();\n    }")
      }
    }

    "Return a cleanup request in JSON (after fix) form for POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", HttpEntity(MediaTypes.`application/json`, """{"cleanup": { "source": {"id":"new", "name": "Quicksort.java", "description":"Quicksort class", "content":"import java.util.Random;\n\npublic class Quicksort {\n  private static Random rand = new Random();\n\n  private static int randomPartition(int[] arr, int left, int right) {\n    int swapIndex = left + rand.nextInt(right - left) + 1;\n    swap(arr, left, swapIndex);\n    return partition(arr, left, right);\n  }\n\n  private static int randomPartition2(int[] arr, int left, int right) {\n    int swapIndex = left + rand.nextInt(right - left) + 1;\n    swap(arr, left, swapIndex);\n    return partition(arr, left, right);\n  }\n\n  private static int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    int i = left - 1;\n    int j = right + 1;\n    while (true) {\n      do\n        j--;\n      while (arr[j] > pivot);\n      do\n        i++;\n      while (arr[i] < pivot);\n      if (i < j)\n        swap(arr, i, j);\n      else\n        return j;\n    }\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n}", "tags":[], "datastructures": [], "algorithms": [], "refactorings": [], "confidence": 2, "comments":[]}, "preprocess":false }}""" )) ~>
        sealRoute(routes) ~> check {
        responseAs[Result].draft.get.before mustEqual Code(id = "new", name = "Quicksort.java", description = "Quicksort class", content = "import java.util.Random;\n\npublic class Quicksort {\n  private static Random rand = new Random();\n\n  private static int randomPartition(int[] arr, int left, int right) {\n    int swapIndex = left + rand.nextInt(right - left) + 1;\n    swap(arr, left, swapIndex);\n    return partition(arr, left, right);\n  }\n\n  private static int randomPartition2(int[] arr, int left, int right) {\n    int swapIndex = left + rand.nextInt(right - left) + 1;\n    swap(arr, left, swapIndex);\n    return partition(arr, left, right);\n  }\n\n  private static int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    int i = left - 1;\n    int j = right + 1;\n    while (true) {\n      do\n        j--;\n      while (arr[j] > pivot);\n      do\n        i++;\n      while (arr[i] < pivot);\n      if (i < j)\n        swap(arr, i, j);\n      else\n        return j;\n    }\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n}")
        responseAs[Result].draft.get.after  mustEqual Code(id = "new", name = "Quicksort.java", description = "Quicksort class", content = "import java.util.Random;\n\npublic class Quicksort {\n  private static Random rand = new Random();\n\n  private static int randomPartition(int[] arr, int left, int right) {\n    int swapIndex = left + rand.nextInt(right - left) + 1;\n    swap(arr, left, swapIndex);\n    return partition(arr, left, right);\n  }\n\n  private static int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    int i = left - 1;\n    int j = right + 1;\n    while (true) {\n      do\n        j--;\n      while (arr[j] > pivot);\n      do\n        i++;\n      while (arr[i] < pivot);\n      if (i < j)\n        swap(arr, i, j);\n      else\n        return j;\n    }\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n}")
      }
    }

    "Return a cleanup request in JSON for FAULTY POST requests to the root path" in {
      Post("/kiwi/eval?auth_token=legolas", HttpEntity(MediaTypes.`application/json`,
        """{"cleanup": { "source": {"id":"new", "name": "Scratched.java", "description":"Scratched class", "content":"public static void main(String[] args) {\n    DateFormat dateFormatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, Locale.getDefault());\n    TimeZone.setDefault(TimeZone.getDefault());\n    SimpleDateFormat simpleDateFormatter = new SimpleDateFormat(\"dd/MM/yyyy\");\n    SimpleDateFormat simpleTimeFormatter = new SimpleDateFormat(\"hh:mm:ss a\");\n    Date today = new Date();\n    String localeFormattedInTime = dateFormatter.format(today);\n    try {\n        Date parsedDate = dateFormatter.parse(localeFormattedInTime);\n        System.out.println(\"Locale:\" + localeFormattedInTime);\n        System.out.println(\"After parsing a date: \" + parsedDate);\n\n        simpleDateFormatter.setTimeZone(TimeZone.getDefault());\n        simpleTimeFormatter.setTimeZone(TimeZone.getDefault());\n\n        String date = simpleDateFormatter.format(today);\n        String time = simpleTimeFormatter.format(today);\n        System.out.println(\"Today's only date: \" + date);\n        System.out.println(\"Today's only time: \" + time);\n\n        //// Locale to UTC converting\n\n        System.out.println(\"TimeZone.getDefault() >>> \" + TimeZone.getDefault());\n\n        simpleDateFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        simpleTimeFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        String utcDate = simpleDateFormatter.format(today);\n        String utcTime = simpleTimeFormatter.format(today);\n        System.out.println(\"Convert into UTC's date: \" + utcDate);\n        System.out.println(\"Convert into UTC's only time: \" + utcTime);\n\n        //// UTC to locale converting\n        /**\n         ** //////EDIT\n        */\n        // at this point your utcDate,utcTime are strings that are formated in UTC\n        // so first you need to parse them back to Dates using UTC format not Locale\n        Date getDate = simpleDateFormatter.parse(utcDate);\n        Date getTime = simpleTimeFormatter.parse(utcTime);\n\n        // NOW after having the Dates you can change the formatters timezone to your\n        // local to format them into strings\n        simpleDateFormatter.setTimeZone(TimeZone.getDefault());\n        simpleTimeFormatter.setTimeZone(TimeZone.getDefault());\n\n        String getLocalDate = simpleDateFormatter.format(getDate);\n        String getLocalTime = simpleTimeFormatter.format(getTime);\n        System.out.println(\"Get local date: \" + getLocalDate);\n        System.out.println(\"Get local time: \" + getLocalTime);\n\n    } catch (ParseException e) {\n        e.printStackTrace();\n    }\n\n}", "tags":[], "datastructures": [], "algorithms": [], "refactorings": [], "confidence": 2, "comments":[]}, "preprocess":true }}""".stripMargin )) ~>
        sealRoute(routes) ~> check {
        responseAs[Result].draft.get.before mustEqual Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "public static void main(String[] args) {\n    DateFormat dateFormatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, Locale.getDefault());\n    TimeZone.setDefault(TimeZone.getDefault());\n    SimpleDateFormat simpleDateFormatter = new SimpleDateFormat(\"dd/MM/yyyy\");\n    SimpleDateFormat simpleTimeFormatter = new SimpleDateFormat(\"hh:mm:ss a\");\n    Date today = new Date();\n    String localeFormattedInTime = dateFormatter.format(today);\n    try {\n        Date parsedDate = dateFormatter.parse(localeFormattedInTime);\n        System.out.println(\"Locale:\" + localeFormattedInTime);\n        System.out.println(\"After parsing a date: \" + parsedDate);\n\n        simpleDateFormatter.setTimeZone(TimeZone.getDefault());\n        simpleTimeFormatter.setTimeZone(TimeZone.getDefault());\n\n        String date = simpleDateFormatter.format(today);\n        String time = simpleTimeFormatter.format(today);\n        System.out.println(\"Today's only date: \" + date);\n        System.out.println(\"Today's only time: \" + time);\n\n        //// Locale to UTC converting\n\n        System.out.println(\"TimeZone.getDefault() >>> \" + TimeZone.getDefault());\n\n        simpleDateFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        simpleTimeFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        String utcDate = simpleDateFormatter.format(today);\n        String utcTime = simpleTimeFormatter.format(today);\n        System.out.println(\"Convert into UTC's date: \" + utcDate);\n        System.out.println(\"Convert into UTC's only time: \" + utcTime);\n\n        //// UTC to locale converting\n        /**\n         ** //////EDIT\n        */\n        // at this point your utcDate,utcTime are strings that are formated in UTC\n        // so first you need to parse them back to Dates using UTC format not Locale\n        Date getDate = simpleDateFormatter.parse(utcDate);\n        Date getTime = simpleTimeFormatter.parse(utcTime);\n\n        // NOW after having the Dates you can change the formatters timezone to your\n        // local to format them into strings\n        simpleDateFormatter.setTimeZone(TimeZone.getDefault());\n        simpleTimeFormatter.setTimeZone(TimeZone.getDefault());\n\n        String getLocalDate = simpleDateFormatter.format(getDate);\n        String getLocalTime = simpleTimeFormatter.format(getTime);\n        System.out.println(\"Get local date: \" + getLocalDate);\n        System.out.println(\"Get local time: \" + getLocalTime);\n\n    } catch (ParseException e) {\n        e.printStackTrace();\n    }\n\n}")
        responseAs[Result].draft.get.after  mustEqual Code(id = "new", name = "Scratched.java", description = "Scratched class", content = "public static void main(String[] args) {\n    DateFormat dateFormatter = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, Locale.getDefault());\n    TimeZone.setDefault(TimeZone.getDefault());\n    SimpleDateFormat simpleDateFormatter = new SimpleDateFormat(\"dd/MM/yyyy\");\n    SimpleDateFormat simpleTimeFormatter = new SimpleDateFormat(\"hh:mm:ss a\");\n    Date today = new Date();\n    String localeFormattedInTime = dateFormatter.format(today);\n    try {\n        Date parsedDate = dateFormatter.parse(localeFormattedInTime);\n        System.out.println(\"Locale:\" + localeFormattedInTime);\n        System.out.println(\"After parsing a date: \" + parsedDate);\n\n        simpleDateFormatter.setTimeZone(TimeZone.getDefault());\n        simpleTimeFormatter.setTimeZone(TimeZone.getDefault());\n\n        String date = simpleDateFormatter.format(today);\n        String time = simpleTimeFormatter.format(today);\n        System.out.println(\"Today's only date: \" + date);\n        System.out.println(\"Today's only time: \" + time);\n\n        //// Locale to UTC converting\n\n        System.out.println(\"TimeZone.getDefault() >>> \" + TimeZone.getDefault());\n\n        simpleDateFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        simpleTimeFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        String utcDate = simpleDateFormatter.format(today);\n        String utcTime = simpleTimeFormatter.format(today);\n        System.out.println(\"Convert into UTC's date: \" + utcDate);\n        System.out.println(\"Convert into UTC's only time: \" + utcTime);\n\n        //// UTC to locale converting\n        /**\n         ** //////EDIT\n        */\n        // at this point your utcDate,utcTime are strings that are formated in UTC\n        // so first you need to parse them back to Dates using UTC format not Locale\n        Date getDate = simpleDateFormatter.parse(utcDate);\n        Date getTime = simpleTimeFormatter.parse(utcTime);\n\n        // NOW after having the Dates you can change the formatters timezone to your\n        // local to format them into strings\n        simpleDateFormatter.setTimeZone(TimeZone.getDefault());\n        simpleTimeFormatter.setTimeZone(TimeZone.getDefault());\n\n        String getLocalDate = simpleDateFormatter.format(getDate);\n        String getLocalTime = simpleTimeFormatter.format(getTime);\n        System.out.println(\"Get local date: \" + getLocalDate);\n        System.out.println(\"Get local time: \" + getLocalTime);\n\n    } catch (ParseException e) {\n        e.printStackTrace();\n    }\n\n}")
      }
    }

  }

}
